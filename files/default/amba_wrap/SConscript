

def chunks(l, n):
    """ Yield successive n-sized chunks from l.
    """
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

#imports 

Import('target env build_mode gem5_num_exts')

if (target == 'verilatedModels'):
   src_files = [ Glob(target + '/*.cpp') + Glob(target + '/verilator/*.cpp') + Glob(target + '/verilator/include/*.cpp') + Glob(target + '/verilator/include/vltstd/*.cpp') + Glob(target + '/cdmahp/*.cpp') + Glob(target + '/cdmahp/gen_cdmahp_mod_cc/*.cpp')]
elif (target == 'bcpfunctional'):
# Important note:
# The BCPMODEL points to the following in the PA model. This is a temporary step in the process of moving the common
# code across the BCP and PA models to a common directory.
# -- pm/pm_platform.cpp, pm/pm_platform.hpp, pm/pm_types.hpp
# -- framework/include/*.h, framework/include/*.hpp
# This means that the BCP library needs the PA library for successful linking
   src_files = [ Glob(target + '/bcpmodel/*.cpp') + Glob(target + '/bcpmodel/test_driver/*.cpp') + Glob(target + '/bcpmodel/functional/toplevel/engines/timed/*.cpp') + Glob(target + '/bcpmodel/functional/toplevel/pm/ppb/*.cpp') + Glob(target + '/bcpmodel/functional/toplevel/pm/tm/*.cpp') + Glob(target + '/bcpmodel/functional/toplevel/pm/traffic/*.cpp') + Glob(target + '/bcpmodel/functional/toplevel/proj/bcp/glue_layer_t/*.cpp') ]
elif (target == 'pa'):
   src_files = [ Glob(target + '/pamodel/*.cpp') + Glob(target + '/pamodel/functional/toplevel/pm/*.cpp') + Glob(target + '/pamodel/functional/toplevel/pm/cden/*.cpp') + Glob(target + '/pamodel/functional/toplevel/pm/tm/*.cpp') + Glob(target + '/pamodel/functional/toplevel/pm/util/*.cpp') + Glob(target + '/pamodel/functional/toplevel/proj/pa/glue_layer_t/*.cpp') ]
else:
   src_files = Glob(target + '/src/*.cpp')

env.StaticLibrary(target,src_files)

if (target == 'gem5'):
    import os
    src_files = []
    if (build_mode == 'debug'):
        source = Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*.do') + \
        Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*.do')  + \
        Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.do')  + \
        Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.do') + \
        Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.do') 
        source2=list(chunks(source,int(len(source)/gem5_num_exts+1)))
        for l in source2:
            src_files.append([ elem for elem in l if ((elem.name != "main.do") & (elem.name != "eventq.do") & (elem.name != "pollevent.do") & (elem.name != "sim_object.do") & (elem.name != "stats_wrap.do") & (elem.name != "stats.i_init.do")) ])
        for i in range(len(src_files)):
            env.StaticLibrary('gem5_ext'+str(i),src_files[i])
#            print "creating dep for " + 'gem5_ext'+str(i)
    if (build_mode == 'release'):
        source =  Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*.o') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*.o') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.o') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.o') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.o') 
        source2=list(chunks(source,int(len(source)/gem5_num_exts+1)))
        for l in source2:
            src_files.append([ elem for elem in l if ((elem.name != "main.o") & (elem.name != "eventq.o") & (elem.name != "pollevent.o") & (elem.name != "sim_object.o") & (elem.name != "stats_wrap.o") & (elem.name != "stats.i_init.o")) ])  # TODO: filter only needed py elements using sth like & ((re.match('.*.py.do',elem.name) == None) | (elem.name == "importer.py.do") | (elem.name == "__init__.py.do")) & ((re.match('.*.i_init.do',elem.name) == None) | (elem.name == "stats.i_init.do"))) ] 
        for i in range(len(src_files)):
            env.StaticLibrary('gem5_ext'+str(i),src_files[i])
#            print "creating dep for " + 'gem5_ext'+str(i)
    if (build_mode == 'fast'):
        source =  Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*.fo') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*.fo') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.fo') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.fo') + \
            Glob(target+os.sep+'gem5'+os.sep+'build'+os.sep+'ARM'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*'+os.sep+'*.fo') 
        source2=list(chunks(source,int(len(source)/gem5_num_exts+1)))
        for l in source2:
            src_files.append([ elem for elem in l if ((elem.name != "main.fo") & (elem.name != "eventq.fo") & (elem.name != "pollevent.fo") & (elem.name != "sim_object.fo") & (elem.name != "stats_wrap.fo") & (elem.name != "stats.i_init.fo")) ])  # TODO: filter only needed py elements using sth like & ((re.match('.*.py.do',elem.name) == None) | (elem.name == "importer.py.do") | (elem.name == "__init__.py.do")) & ((re.match('.*.i_init.do',elem.name) == None) | (elem.name == "stats.i_init.do"))) ] 
        for i in range(len(src_files)):
            env.StaticLibrary('gem5_ext'+str(i),src_files[i])
#            print "creating dep for " + 'gem5_ext'+str(i)
    


